" ==> user warn function
function! EchoWARN(WARN)
    " general purpose function to echo warnings from functions

    let WARN_msg    = toupper(a:WARN)
    let WARN_prefix = " < < ==== "
    let WARN_suffix = " ==== > > "

    echom join([WARN_prefix, WARN_msg, WARN_suffix], " ")
endfunction

" ==> vim-code-dark 
" If you don't like many colors and prefer the conservative style of the standard Visual Studio
" let g:codedark_conservative=1

" Activates italicized comments (make sure your terminal supports italics)
let g:codedark_italics=0
" Make the background transparent
let g:codedark_transparent=0
" If you have vim-airline, you can also enable the provided theme
let g:airline_theme = 'codedark'

" ==> colorscheme 
colorscheme codedark
set background=dark

" ==> vim-gitgutter 
let g:gitgutter_map_keys = 0    " prevent gitgutter to apply any default mappings

" global vairable in milisecond, :h updatetime, default 4s, 
" used to govern refresh rate of gitgutter signs
" set updatetime=100
let g:gitgutter_sign_added              = '+'
let g:gitgutter_sign_modified           = '>'
let g:gitgutter_sign_removed            = 'd'
let g:gitgutter_sign_removed_first_line = '^'
let g:gitgutter_sign_modified_removed   = '<'
let g:gitgutter_max_signs               = 9999

" Jump between hunks
nmap ghn <Plug>(GitGutterNextHunk)
nmap ghp <Plug>(GitGutterPrevHunk)

" Hunk-add and hunk-revert for chunk staging
nmap ghs <Plug>(GitGutterStageHunk)
nmap ghu <Plug>(GitGutterUndoHunk)

" preview hunk
nmap ghP <Plug>(GitGutterPreviewHunk)


" update signs on every file writing 
autocmd! BufWritePost * GitGutter

" ==> lightline.vim 
set laststatus=2    " needed to show lightline
set noshowmode      " lightline already shows vim mode

" integrate git gutter
function! LightlineGitGutter()
    if !get(g:, 'gitgutter_enabled', 0) || strlen(gitbranch#name()) == 0
        return ''
    endif
    let [ l:added, l:modified, l:removed ] = GitGutterGetHunkSummary()
    return printf('+%d ~%d -%d', l:added, l:modified, l:removed)
endfunction

" with integrated gutter and gitbranchname
" buffers shown in tabline via lightline-buffer
set showtabline=2

let g:lightline#bufferline#show_number  = 1
let g:lightline#bufferline#shorten_path = 1
let g:lightline#bufferline#unnamed      = '[No Name]'

let g:lightline = {'active': {}, 'component_function': {}, 'tabline': {}, 'component_type': {}, 'component_expand': {}}
call extend(g:lightline.active, { 'left': [ ['mode', 'paste'], ['readonly', 'filename', 'modified'], ['gitbranch', 'gitstatus' ] ]  })
call extend(g:lightline.active, { 'right': [ ['percent'], ['fileformat', 'fileencoding', 'filetype'] ]  })
call extend(g:lightline.component_function, { 'gitbranch': 'gitbranch#name', 'gitstatus': 'LightlineGitGutter',  })
call extend(g:lightline.tabline, { 'left': [['buffers']] })
call extend(g:lightline.component_type, { 'buffers': 'tabsel' })
call extend(g:lightline.component_expand, {'buffers': 'lightline#bufferline#buffers'})

" ==> built in terminal >=vim-8.1
nnoremap <leader><cr> :vert terminal<CR>
set termwinkey=<C-X>
tnoremap <C-X>n <C-X>N
tnoremap <C-X><C-N> <C-X>N

" ==> vim-sneak
" `sab`: move the cursor immediately, additional matches will be highlighted
" `;`: go to next match, if `s_next` is enabled
" `3;`: go to third match
" `ctrl-o` or ``: go back to starting point
" `s<CR>`: repeat last sneak search
" `S`: search backwards
" `yszxy`: surround brackets up to xy
" `gUz\}`: to upper case the text from cursor until the next instance of the literal \}
let g:sneak#label = 1

" ==> commentary
" mappings
" `gcc`: comment out a line
" `gc`: comment out the target of a motion, e.g. `gca` comments out a paragraph
" `gc` in VM: comment out selection
" `:7,17/Commentaru`: comment out range
" `:g/TODO/Commentary`: comment out matches in `:global` invocation`
" `gcgc`: uncomments adjacent commented lines
" `autocmd FileType apache setlocal commentstring=#\ %s`: adjust comment string per file type

" ==> surround 
" `cs"'`: change surrounds, e.g. "Hello" --> 'Hello' then `cs'<q>` for <q>Hello</q>, then `cst"` for "Hello" and to rm ds"
" `ysiw]`: surround word under curssor with brackets (iw is a text object)
" `yssb`: wrap whole line with parantheses

" ==> indentLine
let g:indentLine_char_list = ['|', '¦', '┆', '┊']
let g:indentLine_setConceal = 0 " keep default conceal settings
let g:vim_json_conceal=0 " disable conceal on json
let g:markdown_syntax_conceal=0 " disable concea on markdown

" ==> vim-highlighter
" default key mappings
" let HiSet   = 'f<CR>'
" let HiErase = 'f<BS>'
" let HiClear = 'f<C-L>'
" let HiFind  = 'f<Tab>'
" synchronize highlighting of the current window with other split windows
nnoremap F<CR> :Hi ==<cr> 	
" swithc back to single window highlighting mode
nnoremap FF<CR> :Hi ==<cr> 	
" jump around highlighted words
nnoremap <CR>   <Cmd>Hi><CR>
nnoremap g<CR>  <Cmd>Hi<<CR>

" ==> ctrlp.vim
let g:ctrlp_custom_ignore = {
    \ 'dir': '\v[\/](\.git|__pycache__|\.dummies|legacy)$',
    \ 'file': '\v\.(pyc|mod|png)$' }
let g:ctrlp_working_path_mode = 'ra'
let g:ctrlp_show_hidden = 0
let g:ctrlp_use_caching = 1
nnoremap <leader>b :CtrlPBuffer<cr>

" ==> scratch buffer
function! Scratch()
    let bnr = bufname('scratch')
    if bnr == 'scratch'
        setlocal switchbuf=useopen
        vert sbuffer scratch
    else
        vsplit
        noswapfile hide enew
        setlocal buftype=nofile
        setlocal bufhidden=hide
        " setlocal nobuflisted
        "lcd ~
        file scratch
    endif
endfunction
nnoremap gs :call Scratch()<cr>

" ==> auxiliary files
let auxDump=[ $HOME."/.vim/tmp/", $HOME."/.tmp/", $HOME."/tmp/", "/tmp/" ]
let &backupdir=join(auxDump, ",")  " store backup files
let &dir=join(auxDump, ",")        " store swap files
let &undodir=join(auxDump, ",")    " store undo files

" ==> leader key
" let mapleader='/' " default
" let mapleader=',' " common alternative

" ==> trim trailing spaces and blank lines at end of the file
function! Preserve(command)
    " Preparation: save last search, and cursor position.
    let _s = @/
    let l  = line(".")
    let c  = col(".")
    " Do the business:
    execute a:command
    " Clean up: restore previous search history, and cursor position
    let @/=_s
    call cursor(l, c)
endfunction

autocmd! BufWritePre * call Preserve("%s/\\S\\zs\ \\+$//e")
autocmd! BufWritePre * call Preserve("%s/\\S\\zs\t\\+$//e")
autocmd! BufWritePre * call Preserve("%s#\\($\\n\\s\*\\)\\+\\%$##e")

" ==> cursorline
let underline_cursorline_fix = 0

augroup HackCursorlineWhenUnderline
    autocmd!
augroup END

if underline_cursorline_fix
    autocmd VimEnter * echom 'cursorline underline hack'

    autocmd HackCursorlineWhenUnderline WinEnter * setlocal cursorline
    autocmd HackCursorlineWhenUnderline WinEnter * setlocal nocursorline
    highlight cursorline cterm=none term=none
    highlight CursorLine guibg=#303000 ctermbg=233
    highlight Visual cterm=reverse ctermfg=NONE
else
    set cursorline  " highlichg current line via colorscheme
endif

" ==> add/del empty lines; https://vim.fandom.com/wiki/Quickly_adding_and_deleting_empty_lines
function! AddEmptyLineBelow()
    call append(line("."), "")
endfunction

function! AddEmptyLineAbove()
    let l:scrolloffsave = &scrolloff
    " Avoid jerky scrolling with ^E at top of window
    set scrolloff=0
    call append(line(".") - 1, "")
    if winline() != winheight(0)
        silent normal! <C-e>
    end
    let &scrolloff = l:scrolloffsave
endfunction

function! DelEmptyLineBelow()
    if line(".") == line("$")
        return
    end
    let l:line = getline(line(".") + 1)
    if l:line =~ '^\s*$'
        let l:colsave = col(".")
        .+1d
        ''
        call cursor(line("."), l:colsave)
    end
endfunction

function! DelEmptyLineAbove()
    if line(".") == 1
        return
    end
    let l:line = getline(line(".") - 1)
    if l:line =~ '^\s*$'
        let l:colsave = col(".")
        .-1d
        silent normal! <C-y>
        call cursor(line("."), l:colsave)
    end
endfunction

" delete/add blank line below/above, and double -- inserts them.
noremap jj :call DelEmptyLineBelow()<CR>
noremap kk :call DelEmptyLineAbove()<CR>
noremap <C-j><C-j> :call AddEmptyLineBelow()<CR>
noremap <C-k><C-k> :call AddEmptyLineAbove()<CR>
