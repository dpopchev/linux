" ==> drop annoying shortcuts
noremap <q-:> <Nop>
noremap <S-k> <Nop>

" ==> gruvbox
let g:gruvbox_contrast_dark      = 'medium'
let g:gruvbox_contrast_light     = 'medium'
let g:gruvbox_bold               = 1
let g:gruvbox_italic             = 0
let g:gruvbox_italicize_comments = 0
let g:gruvbox_invert_selection   = 0

" ==> colorscheme
" manually specify background color -- available are dark and light
set background=dark
" set background=light

" force color; needed TERM=xterm-256color
if !has('gui_running')
    set t_Co=256
endif

let colo_def      = 'gruvbox'   " set default colorscheme
let colo_fallback = 'delek'    " set fallback colorscheme

try
    " try setting the default colorscheme
    exe "colorscheme " . colo_def
catch /^Vim\%((\a\+)\)\=:E185/
    " if it fails try the fallback one
    :call EchoWARN("colorscheme not found " . colo_def)
    :call EchoWARN("will try with fallback: " . colo_fallback)
    exe "colorscheme " . colo_fallback
endtry

" ==> auxiliary files
let auxDump=[ $HOME."/.vim/tmp/", $HOME."/.tmp/", $HOME."/tmp/", "/tmp/" ]
let &backupdir=join(auxDump, ",")  " store backup files
let &dir=join(auxDump, ",")        " store swap files
let &undodir=join(auxDump, ",")    " store undo files

" ==> leader key
" let mapleader='/' " default
" let mapleader=',' " common alternative

" ==> user warn function
function! EchoWARN(WARN)
    " general purpose function to echo warnings from functions

    let WARN_msg    = toupper(a:WARN)
    let WARN_prefix = " < < ==== "
    let WARN_suffix = " ==== > > "

    echom join([WARN_prefix, WARN_msg, WARN_suffix], " ")
endfunction

" ==> trim trailing spaces and blank lines at end of the file
function! Preserve(command)
    " Preparation: save last search, and cursor position.
    let _s = @/
    let l  = line(".")
    let c  = col(".")
    " Do the business:
    execute a:command
    " Clean up: restore previous search history, and cursor position
    let @/=_s
    call cursor(l, c)
endfunction

augroup TrimBlanks
    autocmd!
    autocmd BufWritePre * call Preserve("%s/\\S\\zs\ \\+$//e")
    autocmd BufWritePre * call Preserve("%s/\\S\\zs\t\\+$//e")
    autocmd BufWritePre * call Preserve("%s#\\($\\n\\s\*\\)\\+\\%$##e")
augroup END

" ==> gitgutter; https://github.com/airblade/vim-gitgutter
let g:gitgutter_map_keys = 0    " prevent gitgutter to apply any default mappings

set updatetime=100
let g:gitgutter_sign_added              = '+'
let g:gitgutter_sign_modified           = '>'
let g:gitgutter_sign_removed            = 'd'
let g:gitgutter_sign_removed_first_line = '^'
let g:gitgutter_sign_modified_removed   = '<'
let g:gitgutter_max_signs               = 9999

" Jump between hunks
nmap ghn <Plug>(GitGutterNextHunk)
nmap ghp <Plug>(GitGutterPrevHunk)

" Hunk-add and hunk-revert for chunk staging
nmap ghs <Plug>(GitGutterStageHunk)
nmap ghu <Plug>(GitGutterUndoHunk)

" preview hunk
nmap ghP <Plug>(GitGutterPreviewHunk)

" ==> lightline with integrated gitgutter and gitbranchanme
set laststatus=2    " needed to show lightline
set noshowmode      " lightline already shows vim mode

" integrate git gutter
function! LightlineGitGutter()
    if !get(g:, 'gitgutter_enabled', 0) || strlen(gitbranch#name()) == 0
        return ''
    endif
    let [ l:added, l:modified, l:removed ] = GitGutterGetHunkSummary()
    return printf('+%d ~%d -%d', l:added, l:modified, l:removed)
endfunction

" with integrated gutter and gitbranchname
let g:lightline = {
            \ 'active': {
            \   'left': [ [ 'mode', 'paste' ],
            \             [ 'gitbranch', 'githunks', 'readonly', 'filename', 'modified' ] ]
            \ },
            \ 'component_function': {
            \   'gitbranch': 'gitbranch#name',
            \   'githunks': 'LightlineGitGutter'
            \ },
            \ }

" ==> easy-align; https://github.com/junegunn/vim-easy-align
xmap ga <Plug>(EasyAlign)
nmap ga <Plug>(EasyAlign)

" ==> indentLine; https://github.com/Yggdroot/indentLine.git
" each level with separate char
let g:indentLine_char_list = ['|', '¦', '┆', '┊']

" ==>  ctrlp.vim; https://github.com/ctrlpvim/ctrlp.vim
" ==> nerdtree; https://github.com/preservim/nerdtree.git
nnoremap <leader>t :NERDTreeFind<cr>
nnoremap <leader>T :NERDTreeToggle<cr>
" in case I want to switch
let g:NERDTreeDirArrowExpandable  = '▸'
let g:NERDTreeDirArrowCollapsible = '▾'
" fuzzy search files
set wildignore+=*/tmp/*,*.so,*.swp,*.zip,*.tar*,*.rar     " MacOSX/Linux
let g:ctrlp_custom_ignore = '\v[\/]\.(git|hg|svn)$'
let g:ctrlp_custom_ignore = {
            \ 'dir':  '\v[\/]\.(git|hg|svn)$',
            \ 'file': '\v\.(exe|so|dll)$',
            \ 'link': 'some_bad_symbolic_links',
            \ }
let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files -co --exclude-standard']

" ==> vim-sneak
let g:sneak#label = 1

" ==> goyou; https://github.com/junegunn/goyo.vim
let g:goyo_linenr = 1
let g:goyo_height = '100%'
let g:goyo_width  = 82
let g:goyo_margin_top = 0
let g:goyo_margin_bottom = 0

nnoremap <leader>e :Goyo<cr>

augroup goyou_enable_plugins
    autocmd!
    autocmd User GoyoEnter :GitGutterToggle
augroup END

" ==> vim-illuminate
let g:Illuminate_delay = 250
let g:Illuminate_highlightUnderCursor = 1
nnoremap z/ :IlluminationToggle<cr>
" NOTE: has extensive blocklist capabilities
" let g:Illuminate_ftblacklist = ['nerdtree']
augroup illuminate_augroup
    autocmd!
    autocmd VimEnter * hi illuminatedWord cterm=bold,underline
    autocmd User GoyoLeave nested hi illuminatedWord cterm=bold,underline
augroup END

" ==> vim-anyfold
augroup vim_anyfold_active
    autocmd!
    autocmd Filetype * AnyFoldActivate               " activate for all filetypes
augroup END
let g:anyfold_fold_comments=1
