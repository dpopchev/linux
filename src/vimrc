" ==> vim-code-dark
" If you don't like many colors and prefer the conservative style of the standard Visual Studio
let g:codedark_conservative=0
" Activates italicized comments (make sure your terminal supports italics)
let g:codedark_italics=0
" Make the background transparent
let g:codedark_transparent=0

" ==> colorscheme
set background=dark
" set background=light

" load specific scheme, note desert is nice built-in
colorscheme codedark

" ==> sensible
" 'backspace': Backspace through anything in insert mode.
" 'incsearch': Start searching before pressing enter.
" 'listchars': Makes :set list (visible whitespace) prettier.
" 'scrolloff': Always show at least one line above/below the cursor.
" 'autoread': Autoload file changes. You can undo by pressing u.
" runtime! macros/matchit.vim: Load the version of matchit.vim that ships with Vim.
"
" ==> commentary
" `gcc`: comment out a line (takes a count)
" `gc`: to comment out the target of a motion, e.g. `gcap` to comment out a paragraph)
" `gc`: in visual mode to comment out the selection
" `gc`: in operator pending mode to target a comment
" `:7,17Commentary`: use it as a command
" `:g/TODO/Commentary`: use as a global invocation

" ==> vim-polyglot
" markdown
let g:vim_markdown_no_default_key_mappings = 1
let g:vim_markdown_conceal = 0
let g:vim_markdown_auto_insert_bullets = 0
let g:vim_markdown_new_list_item_indent = 0

augroup ForceSetNoConcealLevel
    autocmd!
    autocmd FileType markdown,md setlocal commentstring=<!--\ %s\ -->
    autocmd InsertEnter *.{markdown,md} setlocal conceallevel=0
    autocmd InsertLeave *.{markdown,md} setlocal conceallevel=0
augroup END

" ==> surround
" `cs"'`: change "Hello" to 'Hello'
" `cs'<q>`: change 'Hello' to <q>Hello</q>
" `cst"`: change <q>Hello</q> to "Hello"
" `ds"`: remove double quaotes in Hello
" `ysiw]`: surround word under cursor, `iw` is a text object
" `cs[}`: change surrounding brackets
" `yssb`: wrap line in parentheses
" `ds{`: remove line paranthesis

" ==> vim-sneak
" `sab`: move cursor immediately if singe match, or highlighted other matches
" `;`: go to next match
" `3;`: got to 3rd match
" C-O or ``: jump back to starting point
" `s<CR>`: repeat last sneak search
" `S`: sneak backwards
" `yszxy]`: surround in brackets up to 'xy'
" `gUz\}`: to upper case text from curssor until literal text \}
let g:sneak#label = 1

" ==> repeat

" ==> editor
" line numbers
set number
set relativenumber

" alternative line numbering configuration
" set relativenumber nonumber
" autocmd! InsertEnter * :setlocal norelativenumber number
" autocmd! InsertLeave * :setlocal relativenumber  nonumber

" trailing text in all directions
set scrolloff=3
set sidescrolloff=3

" text width and end of line control
let textThreshold = 80             " set desired text width
let &textwidth = textThreshold     " maximum allowed width of a line
let &colorcolumn = textThreshold+1 " set text length marker
set nowrap                       " disable line wrap
set linebreak                    " avoid wrapping a line in middle of a word

set display=lastline    " display as much as possible of a line

set cursorline  " highlichg current line via colorscheme

" paste insert mode control
nnoremap ++ :set invpaste<cr>

" visual guides for blank characters
set list listchars=tab:❘-,trail:·,extends:»,precedes:«,nbsp:×

" misc
set noruler         " do not display cursor position
set showcmd         " show command in last line of the screen
set wildmenu        " shown possible matches just above command line
set title           " set window title to opened file
set noerrorbells    " disable beep on errors
set novisualbell    " disable flash the screen instead of beeping on errors
set mouse=n         " enable mouse only in normal mode
set showmatch           " highlight matching brackets
" set matchtime=5       " tenths of a second to show matching bracket parent
" set matchpairs+=<:>   " extend match pairs with < and >

autocmd! FileType,BufWinEnter * setlocal formatoptions-=o

" ==> built in terminal >=vim-8.1
nnoremap <leader><cr> :vert terminal<CR>
set termwinkey=<C-X>
tnoremap <C-X>n <C-X>N
tnoremap <C-X><C-N> <C-X>N

" ==> vim-gitgutter
let g:gitgutter_map_keys = 0    " prevent gitgutter to apply any default mappings

let g:gitgutter_sign_added              = '+'
let g:gitgutter_sign_modified           = '>'
let g:gitgutter_sign_removed            = 'd'
let g:gitgutter_sign_removed_first_line = '^'
let g:gitgutter_sign_modified_removed   = '<'
let g:gitgutter_max_signs               = 9999

" Jump between hunks
nmap ghn <Plug>(GitGutterNextHunk)
nmap ghp <Plug>(GitGutterPrevHunk)

" Hunk-add and hunk-revert for chunk staging
nmap ghs <Plug>(GitGutterStageHunk)
nmap ghu <Plug>(GitGutterUndoHunk)

" preview hunk
nmap ghP <Plug>(GitGutterPreviewHunk)

" update signes when saving a file
autocmd! BufWritePost * GitGutter

" ==> lightline.vim, vim-gitbranch, lightline-bufferline
set laststatus=2    " needed to show lightline
set noshowmode      " lightline already shows vim mode

" integrate git gutter
function! LightlineGitGutter()
    if !get(g:, 'gitgutter_enabled', 0) || strlen(gitbranch#name()) == 0
        return ''
    endif
    let [ l:added, l:modified, l:removed ] = GitGutterGetHunkSummary()
    return printf('+%d ~%d -%d', l:added, l:modified, l:removed)
endfunction

" with integrated gutter and gitbranchname
" buffers shown in tabline via lightline-buffer
set showtabline=2

let g:lightline#bufferline#show_number  = 1
let g:lightline#bufferline#shorten_path = 1
let g:lightline#bufferline#unnamed      = '[No Name]'

let g:lightline = {'active': {}, 'component_function': {}, 'tabline': {}, 'component_type': {}, 'component_expand': {}}
call extend(g:lightline.active, { 'left': [ ['mode', 'paste'], ['readonly', 'filename', 'modified'], ['gitbranch', 'gitstatus' ] ]  })
call extend(g:lightline.active, { 'right': [ ['percent'], ['fileformat', 'fileencoding', 'filetype'] ]  })
call extend(g:lightline.component_function, { 'gitbranch': 'gitbranch#name', 'gitstatus': 'LightlineGitGutter',  })
call extend(g:lightline.tabline, { 'left': [['buffers']] })
call extend(g:lightline.component_type, { 'buffers': 'tabsel' })
call extend(g:lightline.component_expand, {'buffers': 'lightline#bufferline#buffers'})

" ==> ctrlp.vim
" fuzzy search files
let g:ctrlp_custom_ignore = {
    \ 'dir': '\v[\/](\.git|__pycache__|\.dummies|legacy)$',
    \ 'file': '\v\.(pyc|mod|png)$' }
let g:ctrlp_working_path_mode = 'ra'
let g:ctrlp_show_hidden = 0
let g:ctrlp_use_caching = 1
nnoremap <leader>b :CtrlPBuffer<cr>
nnoremap <leader>t :CtrlPTag<cr>
nnoremap <leader>m :CtrlPModified<cr>

" ==> leader maps
" let mapleader='/' " default
" let mapleader=',' " common alternative
nnoremap <leader>q :q<cr>
nnoremap <leader>w :w<cr>
noremap <leader>r i<cr><esc>
noremap <leader><space> i<space><esc>
noremap <leader><leader><space> a<space><esc>
vnoremap <leader>y "yy
vnoremap <leader>Y "Yy
vnoremap <leader><leader>y "yp
nnoremap <leader><leader>y "yp
vnoremap <leader>p "py
vnoremap <leader>P "Py
vnoremap <leader><leader>p "pp
nnoremap <leader><leader>p "pp

" ==> indentLine
" each level with separate char
let g:indentLine_char_list = ['|', '¦', '┆', '┊']
let g:indentLine_indentLevel = 5
let g:indentLine_faster = 1

" ==> vim-highlighter
" let HiSet   = 'f<CR>'
" let HiErase = 'f<BS>'
" let HiClear = 'f<C-L>'
" let HiFind  = 'f<Tab>'
" enable/disable highlither to all buffers
nnoremap F<CR> :Hi ==<cr>
nnoremap FF<CR> :Hi =<cr>
" jump forward/back to marks
nnoremap <CR>   <Cmd>Hi><CR>
nnoremap g<CR>  <Cmd>Hi<<CR>

" ==> create scratch buffer
" scratch.vim
let g:scratch_horizontal = 0
let g:scratch_insert_autohide = 0

" manual definition
"function! Scratch()
"    let bnr = bufname('scratch')
"    if bnr == 'scratch'
"        setlocal switchbuf=useopen
"        vert sbuffer scratch
"    else
"        vsplit
"        noswapfile hide enew
"        setlocal buftype=nofile
"        setlocal bufhidden=hide
"        " setlocal nobuflisted
"        "lcd ~
"        file scratch
"    endif
"endfunction
"nnoremap gs :call Scratch()<cr>

" ==> auxiliary files
let auxDump=[ $HOME."/.vim/tmp/", $HOME."/.tmp/", $HOME."/tmp/", "/tmp/" ]
let &backupdir=join(auxDump, ",")  " store backup files
let &dir=join(auxDump, ",")        " store swap files
let &undodir=join(auxDump, ",")    " store undo files

" ==> trim trailing spaces and blank lines at end of the file
function! Preserve(command)
    " Preparation: save last search, and cursor position.
    let _s = @/
    let l  = line(".")
    let c  = col(".")
    " Do the business:
    execute a:command
    " Clean up: restore previous search history, and cursor position
    let @/=_s
    call cursor(l, c)
endfunction

augroup TrimBlanks
    autocmd!
    autocmd BufWritePre * call Preserve("%s/\\S\\zs\ \\+$//e")
    autocmd BufWritePre * call Preserve("%s/\\S\\zs\t\\+$//e")
    autocmd BufWritePre * call Preserve("%s#\\($\\n\\s\*\\)\\+\\%$##e")
augroup END

" ==> search
" resource https://vim.fandom.com/wiki/Searching
set hlsearch    " enable search highlighting
set incsearch   " incremental search that shows partial matches
set ignorecase  " ignore case when searching
set smartcase   " automatically switch to case-sensitive when search
set magic       " for regular expressions turn magic on
nnoremap <C-l> :nohlsearch<CR><esc>
nnoremap / /\v

" ==> split
" cheatsheet
" ctrl + w _ " Max out the height of the current split
" ctrl + w | "Max out the width of the current split
" ctrl + w = "Normalize all split sizes, which is very handy when resizing terminal
" Ctrl+W R "Swap top/bottom or left/right split
" Ctrl+W T "Break out current window into a new tabview
" Ctrl+W o "Close every window in the current tabview but the current one

set splitbelow
set splitright

" ==> buffers
" augroup IgnoreTerminalFromBufferList
"     autocmd!
"     autocmd TerminalOpen * if bufwinnr('') > 0 | setlocal nobuflisted | endif
" augroup END

set switchbuf=useopen
nnoremap [b :bprev<CR>
nnoremap ]b :bnext<CR>
nnoremap gbd :bprevious<CR> :bdelete #<CR>
nnoremap gbl :ls<CR>
nnoremap gbb :ls<CR>:b
" nnoremap gb :b
let buf_num = 1
let buf_count = 99
while buf_num <= buf_count
  execute "nnoremap " . buf_num . "gb :vert sbuffer" . buf_num . "\<CR>"
  let buf_num += 1
endwhile

set hidden

" ==> diff
if &diff
    " diff mode ignore white spaces
    set diffopt+=iwhite

    " put/obtain line cursor is on
    nnoremap gdp V:diffput<cr>
    nnoremap gdo V:diffget<cr>
    vnoremap gdp <esc>gv:diffput<cr>
    vnoremap gdo <esc>gv:diffget<cr>

    " undo the other, inactive window
    nnoremap gdu :wincmd w<cr>:normal u<cr>:wincmd w<cr>

    " recalculate differences
    nnoremap gdr :diffupdate<cr>
endif

" ==> add/del empty lines; https://vim.fandom.com/wiki/Quickly_adding_and_deleting_empty_lines
function! AddEmptyLineBelow()
    call append(line("."), "")
endfunction

function! AddEmptyLineAbove()
    let l:scrolloffsave = &scrolloff
    " Avoid jerky scrolling with ^E at top of window
    set scrolloff=0
    call append(line(".") - 1, "")
    if winline() != winheight(0)
        silent normal! <C-e>
    end
    let &scrolloff = l:scrolloffsave
endfunction

function! DelEmptyLineBelow()
    if line(".") == line("$")
        return
    end
    let l:line = getline(line(".") + 1)
    if l:line =~ '^\s*$'
        let l:colsave = col(".")
        .+1d
        ''
        call cursor(line("."), l:colsave)
    end
endfunction

function! DelEmptyLineAbove()
    if line(".") == 1
        return
    end
    let l:line = getline(line(".") - 1)
    if l:line =~ '^\s*$'
        let l:colsave = col(".")
        .-1d
        silent normal! <C-y>
        call cursor(line("."), l:colsave)
    end
endfunction

" delete/add blank line below/above, and double -- inserts them.
" del is map with Alt key, it may not show when text copied around
" to make a alt combination, e.g. A-j, in insert mode hit Ctrl+V then Alt+j
noremap jj :call DelEmptyLineBelow()<CR>
noremap kk :call DelEmptyLineAbove()<CR>
noremap <C-j><C-j> :call AddEmptyLineBelow()<CR>
noremap <C-k><C-k> :call AddEmptyLineAbove()<CR>

" ==> fold
" folding cheat sheet
"   zc/o/a      close/open/toggle fold if the cursor is on one
"   zC/O/A      close/open/toggle all fold levels around the cursor
"   zr/m        reduce/increasing folding by opening/closing one more fold level
"   zR/M        reduce/increasing folding by opening/closing one more fold level at all buffer
"   zf#j/k      create fold from cursor down/up # number of lines
"   zj/k        move cursor to next fold down/up

" ==> completion
" C-N: insert next matching word
" C-P: insert previous mathcing word
" C-X C-N: local keyword completion
" C-X C-F: file path completion
" C-X C-O: omni completion after typing
" C-X C-K: dictionary words
" C-X C-U: user defined completion
" C-X C-]: tags
" C-X C-V: vim command

set complete+=kspell " use currently active spell checking
" set complete-=t      " use C-X C-]
" set complete-=i      " use C-X C-I
" set completeopt=menuone,preview,noselect
set completeopt=longest,menuone
set omnifunc=syntaxcomplete#Complete

" ==> spell
"   move to misspelled words via            ]s and [s
"   change word under cursor via            z=
"   add word under cursor to dictionary     zg
"   remove word from dictionary via         zw
" to auto download spell, this should be the def site
" when vim starts first disable :set nospell and then enable :set spell
let g:spellfile_URL = 'http://ftp.vim.org/vim/runtime/spell'
set spell          " enable spellcheck
set spelllang=en   " spellcheck language
" set spelllang+=bg  " spellcheck language
"set spellfile=... " place to store additional words

augroup SaneSpellCheckHi
    autocmd!
    autocmd BufEnter * :hi clear SpellBad
    autocmd BufEnter * :hi SpellBad cterm=underline
    autocmd BufEnter * :hi clear SpellRare
    autocmd BufEnter * :hi SpellRare cterm=underline
    autocmd BufEnter * :hi clear SpellCap
    autocmd BufEnter * :hi SpellCap cterm=none
    autocmd BufEnter * :hi clear SpellLocal
    autocmd BufEnter * :hi SpellLocal cterm=underline
augroup END

" ==> indent
" resource https://vim.fandom.com/wiki/Indenting_source_code
" set amount of spaces for indentation
let b:indent=4

" indentation without hard tabs
set expandtab             " convert tabs to 'softtabstop' amount of spaces
let &shiftwidth=b:indent  " affects when pressing >>, << or == and auto indentation
let &softtabstop=b:indent " affects <TAB> or <BS>;
" let &tabstop=b:indent   " not recommended as may alter view of other editors

" ==> make/build/compile/run/lint/test/autoformat Makefile shortcuts
" file vise targets
nnoremap m<cr> :silent make! compile FILE=%<bar>redraw!<bar>copen<cr>
nnoremap mm<cr> :silent make! format FILE=%<bar>redraw!<cr>
nnoremap ml :silent make! lint FILE=%<bar>redraw!<bar>copen<cr>
nnoremap mr :silent make! run FILE=%<bar>redraw!<bar>copen<cr>
nnoremap mt :silent make! doctest FILE=%<bar>redraw!<bar>copen<cr>

augroup QuickFixListBottomHack
    autocmd!
    autocmd FileType qf wincmd L
augroup END

" ==> vim-easy-align
" ==> auto-pairs
" ==> ctags
" C + ] or g]: jump to tag underneath
" C + w }: open preview window with location of tag definition
" C + w C + ]: open definition in horizontal split
