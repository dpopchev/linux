" ==> user warn function
function! EchoWARN(WARN)
    " general purpose function to echo warnings from functions

    let WARN_msg    = toupper(a:WARN)
    let WARN_prefix = " < < ==== "
    let WARN_suffix = " ==== > > "

    echom join([WARN_prefix, WARN_msg, WARN_suffix], " ")
endfunction

" ==> vim-code-dark 
" If you don't like many colors and prefer the conservative style of the standard Visual Studio
let g:codedark_conservative=1
" Activates italicized comments (make sure your terminal supports italics)
let g:codedark_italics=0
" Make the background transparent
let g:codedark_transparent=0
" If you have vim-airline, you can also enable the provided theme
let g:airline_theme = 'codedark'

" ==> colorscheme 
colorscheme codedark

" ==> vim-gitgutter 
let g:gitgutter_map_keys = 0    " prevent gitgutter to apply any default mappings

set updatetime=100
let g:gitgutter_sign_added              = '+'
let g:gitgutter_sign_modified           = '>'
let g:gitgutter_sign_removed            = 'd'
let g:gitgutter_sign_removed_first_line = '^'
let g:gitgutter_sign_modified_removed   = '<'
let g:gitgutter_max_signs               = 9999

" Jump between hunks
nmap ghn <Plug>(GitGutterNextHunk)
nmap ghp <Plug>(GitGutterPrevHunk)

" Hunk-add and hunk-revert for chunk staging
nmap ghs <Plug>(GitGutterStageHunk)
nmap ghu <Plug>(GitGutterUndoHunk)

" preview hunk
nmap ghP <Plug>(GitGutterPreviewHunk)

" ==> lightline.vim 
set laststatus=2    " needed to show lightline
set noshowmode      " lightline already shows vim mode

" integrate git gutter
function! LightlineGitGutter()
    if !get(g:, 'gitgutter_enabled', 0) || strlen(gitbranch#name()) == 0
        return ''
    endif
    let [ l:added, l:modified, l:removed ] = GitGutterGetHunkSummary()
    return printf('+%d ~%d -%d', l:added, l:modified, l:removed)
endfunction

" with integrated gutter and gitbranchname
" buffers shown in tabline via lightline-buffer
set showtabline=2

let g:lightline#bufferline#show_number  = 1
let g:lightline#bufferline#shorten_path = 1
let g:lightline#bufferline#unnamed      = '[No Name]'

let g:lightline = {'active': {}, 'component_function': {}, 'tabline': {}, 'component_type': {}, 'component_expand': {}}
call extend(g:lightline.active, { 'left': [ ['mode', 'paste'], ['readonly', 'filename', 'modified'], ['gitbranch', 'gitstatus' ] ]  })
call extend(g:lightline.active, { 'right': [ ['percent'], ['fileformat', 'fileencoding', 'filetype'] ]  })
call extend(g:lightline.component_function, { 'gitbranch': 'gitbranch#name', 'gitstatus': 'LightlineGitGutter',  })
call extend(g:lightline.tabline, { 'left': [['buffers']] })
call extend(g:lightline.component_type, { 'buffers': 'tabsel' })
call extend(g:lightline.component_expand, {'buffers': 'lightline#bufferline#buffers'})

" ==> built in terminal >=vim-8.1
nnoremap <leader><cr> :vert terminal<CR>
set termwinkey=<C-X>
tnoremap <C-X>n <C-X>N
tnoremap <C-X><C-N> <C-X>N

" ==> vim-sneak
" `sab`: move the cursor immediately, additional matches will be highlighted
" `;`: go to next match, if `s_next` is enabled
" `3;`: go to third match
" `ctrl-o` or ``: go back to starting point
" `s<CR>`: repeat last sneak search
" `S`: search backwards
" `yszxy`: surround brackets up to xy
" `gUz\}`: to upper case the text from cursor until the next instance of the literal \}
let g:sneak#label = 1

" ==> commentary
" mappings
" `gcc`: comment out a line
" `gc`: comment out the target of a motion, e.g. `gca` comments out a paragraph
" `gc` in VM: comment out selection
" `:7,17/Commentaru`: comment out range
" `:g/TODO/Commentary`: comment out matches in `:global` invocation`
" `gcgc`: uncomments adjacent commented lines
" `autocmd FileType apache setlocal commentstring=#\ %s`: adjust comment string per file type

" ==> surround 
" `cs"'`: change surrounds, e.g. "Hello" --> 'Hello' then `cs'<q>` for <q>Hello</q>, then `cst"` for "Hello" and to rm ds"
" `ysiw]`: surround word under curssor with brackets (iw is a text object)
" `yssb`: wrap whole line with parantheses
