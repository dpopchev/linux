# some of the complicated stuff are adopted from Gentoo bashrc, available online

# Test for an interactive shell.  There is no need to set anything
# past this point for scp and rcp, and it's important to refrain from
# outputting anything in those cases.
if [[ $- != *i* ]] ; then
        # Shell is non-interactive.  Be done now!
        return
fi

# EXPECTED_BASH_COMPLETION=/usr/share/bash-completion/bash_completion
EXPECTED_BASH_COMPLETION=~/.local/share/bash-completion/bash_completion
# Use bash-completion, if available
[[ $PS1 && -f $EXPECTED_BASH_COMPLETION ]] && . $EXPECTED_BASH_COMPLETION

# Bash won't get SIGWINCH if another process is in the foreground.
# Enable checkwinsize so that bash will check the terminal size when
# it regains control.  #65623
# http://cnswww.cns.cwru.edu/~chet/bash/FAQ (E11)
shopt -s checkwinsize

# Disable completion when the input buffer is empty.  i.e. Hitting tab
# and waiting a long time for bash to expand all of $PATH.
shopt -s no_empty_cmd_completion

# Enable history appending instead of overwriting when exiting.  #139609
shopt -s histappend

# Save each command to the history file as it's executed.  #517342
# This does mean sessions get interleaved when reading later on, but this
# way the history is always up to date.  History is not synced across live
# sessions though; that is what `history -n` does.
# Disabled by default due to concerns related to system recovery when $HOME
# is under duress, or lives somewhere flaky (like NFS).  Constantly syncing
# the history will halt the shell prompt until it's finished.
PROMPT_COMMAND='history -a'

# not part of Gentoo bashrc, but logically should be here
# it makes history to ignore both commands starting with a space and duplicates
HISTCONTROL='ignoreboth'

# Change the window title of X terminals
case ${TERM} in
        [aEkx]term*|rxvt*|gnome*|konsole*|interix|tmux*)
                PS1='\[\033]0;\u@\h:\w\007\]'
                ;;
        screen*)
                PS1='\[\033k\u@\h:\w\033\\\]'
                ;;
        *)
                unset PS1
                ;;
esac

# Set colorful PS1 only on colorful terminals.
# dircolors --print-database uses its own built-in database
# instead of using /etc/DIR_COLORS.  Try to use the external file
# first to take advantage of user additions.
# We run dircolors directly due to its changes in file syntax and
# terminal name patching.
use_color=false
if type -P dircolors >/dev/null ; then
        # Enable colors for ls, etc.  Prefer ~/.dir_colors #64489
        LS_COLORS=
        if [[ -f ~/.dir_colors ]] ; then
                eval "$(dircolors -b ~/.dir_colors)"
        elif [[ -f /etc/DIR_COLORS ]] ; then
                eval "$(dircolors -b /etc/DIR_COLORS)"
        else
                eval "$(dircolors -b)"
        fi
        # Note: We always evaluate the LS_COLORS setting even when it's the
        # default.  If it isn't set, then `ls` will only colorize by default
        # based on file attributes and ignore extensions (even the compiled
        # in defaults of dircolors). #583814
        if [[ -n ${LS_COLORS:+set} ]] ; then
                use_color=true
        else
                # Delete it if it's empty as it's useless in that case.
                unset LS_COLORS
        fi
else
        # Some systems (e.g. BSD & embedded) don't typically come with
        # dircolors so we need to hardcode some terminals in here.
        case ${TERM} in
        [aEkx]term*|rxvt*|gnome*|konsole*|screen|tmux|cons25|*color) use_color=true;;
        esac
fi

# functions for quick PATH manipulation
PATH_remove() {
    # remove argument from PATH
    # return 0 if successful or otherwise if not

    # exit code variable
    r=0;

    # will remove a single path at a time
    if [[ $# -ne 1 ]]; then
        echo "please provide only one path";
        r=1;
    fi;

    # unify
    _PATH=":${PATH}:";

    # remove argument
    _PATH="${_PATH//:$1:/:}";

    # remove residual characters
    _PATH="${_PATH%:}";
    _PATH="${_PATH#:}";

    # overwrite
    PATH="${_PATH}";

    return $r
}

PATH_append() {
    # append argument to PATH
    # return 0 if successful or otherwise if not

    # exit code variable
    r=0;

    # will append single path at a time
    if [[ $# -ne 1 ]]; then
        echo "please provide only one path";
        r=1;
    fi;

    # check if path is valid
    if [[ $r -eq 0 ]] && [[ ! -d $1 ]]; then
        echo "path $1 does not exist";
        r=1;
    fi;

    # make sure we will not duplicate before appending
    if [[ $r -eq 0 ]]; then
        PATH_remove $1;
        PATH="${PATH}:${1}";
    fi;

    return $r
}

PATH_preappend() {
    # pre-append argument to PATH
    # return 0 if successful or otherwise if not

    # exit code variable
    r=0;

    # will pre-append single path at a time
    if [[ $# -ne 1 ]]; then
        echo "please provide only one path";
        r=1;
    fi;

    # check if path is valid
    if [[ $r -eq 0 ]] && [[ ! -d $1 ]]; then
        echo "path $1 does not exist";
        r=1;
    fi;

    # make sure we will not duplicate before pre-appending
    if [[ $r -eq 0 ]]; then
        PATH_remove $1;
        PATH="${1}:${PATH}";
    fi;

    return $r
}

# functions for quick CDPATH manipulation
CDPATH_remove() {
    # remove argument from CDPATH
    # return 0 if successful or otherwise if not

    # exit code variable
    r=0;

    # will remove a single path at a time
    if [[ $# -ne 1 ]]; then
        echo "please provide only one path";
        r=1;
    fi;

    # unify
    _CDPATH=":${CDPATH}:";

    # remove argument
    _CDPATH="${_CDPATH//:$1:/:}";

    # remove residual characters
    _CDPATH="${_CDPATH%:}";
    _CDPATH="${_CDPATH#:}";

    # overwrite
    CDPATH="${_CDPATH}";

    return $r
}

CDPATH_append() {
    # append argument to CDPATH
    # return 0 if successful or otherwise if not

    # exit code variable
    r=0;

    # will append single path at a time
    if [[ $# -ne 1 ]]; then
        echo "please provide only one path";
        r=1;
    fi;

    # check if path is valid
    if [[ $r -eq 0 ]] && [[ ! -d $1 ]]; then
        echo "path $1 does not exist";
        r=1;
    fi;

    # make sure we will not duplicate before appending
    if [[ $r -eq 0 ]]; then
        CDPATH_remove $1;
        CDPATH="${CDPATH}:${1}";
    fi;

    return $r
}

CDPATH_preappend() {
    # pre-append argument to CDPATH
    # return 0 if successful or otherwise if not

    # exit code variable
    r=0;

    # will pre-append single path at a time
    if [[ $# -ne 1 ]]; then
        echo "please provide only one path";
        r=1;
    fi;

    # check if path is valid
    if [[ $r -eq 0 ]] && [[ ! -d $1 ]]; then
        echo "path $1 does not exist";
        r=1;
    fi;

    # make sure we will not duplicate before pre-appending
    if [[ $r -eq 0 ]]; then
        CDPATH_remove $1;
        CDPATH="${1}:${CDPATH}";
    fi;

    return $r
}

CDPATH=".:${HOME}/projects:${HOME}"

function join_by { local IFS="$1"; shift; echo "$*"; }

ps1_status() {

    local exitcode=$?
    local attr_reset='\001\033[00m\002'
    local attr_light_red='\001\033[91m\002'
    local attr_yellow='\001\033[93m\002'

    local -a result

    if [[ $exitcode == 0 ]]; then
        # command succeed, no worries
        result+=()
    else
        result+=("${attr_light_red}")
        result+=("${exitcode}")
        result+=("${attr_reset}")
    fi

    local suspended_jobs=$(jobs -s | wc -l)
    if [[ $suspended_jobs == 0 ]]; then
        # no suspended jobs, no worries
        result+=()
    else
        result+=("${attr_yellow}")
        result+=("${suspended_jobs}")
        result+=("${attr_reset}")
    fi

    local IFS=' '
    echo -e "${result[*]}"
}

ps1_user_hostname() {

    local attr_reset='\001\033[00m\002'
    local attr_bold_green='\001\033[01;32m\002'

    local result="${attr_bold_green}\u@\h${attr_reset}"

    # echo -e ${result@P}
}

ps1_cwd() {
    local attr_reset='\001\033[00m\002'
    local attr_bold_blue='\001\033[01;34m\002'

    local result="${attr_bold_blue}\w${attr_reset}"

    # echo -e ${result@P}
}

ps1_git_branch() {

    local attr_reset='\001\033[00m\002'
    local attr_cyan='\001\033[36m\002'
    local attr_bold_blue='\001\033[01;34m\002'

    local branches

    local result
    if branches=$(git branch 2>/dev/null); then
        local branch=$(echo "$branches" | sed -rn 's/^[[:blank:]]*\*[[:blank:]]+([a-zA-Z0-9/-]+)/(\1)/p')
        result="${attr_cyan}${branch}${attr_reset}${attr_bold_blue} \$${attr_reset}"
    else
        result="${attr_bold_blue}\$${attr_reset}"
    fi

    echo -e ${result}
}

# show the closes directory parent in the PS1
PROMPT_DIRTRIM=2

# enclose the colors inside \[ \] or terminal will overlap long lines
# https://askubuntu.com/a/111849
if ${use_color} ; then
        if [[ ${EUID} == 0 ]] ; then
                # user is root
                PS1+='\[\033[01;31m\]\h\[\033[01;34m\] \w \$\[\033[00m\] '
        else
                # user is not root
                # PS1+='$(ps1_status)$(ps1_user_hostname) $(ps1_cwd) $(ps1_git_branch) '
                PS1+='$(ps1_status)\001\033[01;32m\002\u@\h\001\033[00m\002 \001\033[01;34m\002\w\001\033[00m\002 $(ps1_git_branch) '
        fi
else
        # show root@ when we don't have colors
        PS1+='\u@\h \w \$ '
fi

unset use_color

declare -a FILES_SOURCE
FILES_SOURCE+=('/usr/share/bash-completion/bash_completion')
FILES_SOURCE+=("${HOME}/.aliases")
FILES_SOURCE+=("${HOME}/.aliases.private")
FILES_SOURCE+=("${HOME}/.env_proxy")
FILES_SOURCE+=("${HOME}/.env_perl")
for sourcefile in "${FILES_SOURCE[@]}"; do
    [[ -r $sourcefile ]] && source "$sourcefile"
done
unset FILES_SOURCE
unset sourcefile

declare -a PATH_CLEAN_FROM
for pathclean in ${PATH_CLEAN_FROM[@]}; do
    [[ ! -d $pathclean ]] && PATH_remove "$pathclean"
done
unset PATH_CLEAN_FROM
unset pathclean

# nice bash features
shopt -s autocd
shopt -s cdspell
shopt -s checkjobs
shopt -s dirspell

# TODO maybe this can be done in inputrc?
# disable Ctrl+S/Q
stty stop ''
stty start ''
stty -ixon
stty -ixoff

# some important vairbales
export EDITOR='vim'
export VISUAL='vim'
export PAGER='less -R'

# ex - archive extractor
# usage: ex <file>
ex ()
{
  if [ -f $1 ] ; then
    case $1 in
      *.tar.bz2)   tar xjf $1   ;;
      *.tar.gz)    tar xzf $1   ;;
      *.bz2)       bunzip2 $1   ;;
      *.rar)       unrar x $1     ;;
      *.gz)        gunzip $1    ;;
      *.tar)       tar xf $1    ;;
      *.tbz2)      tar xjf $1   ;;
      *.tgz)       tar xzf $1   ;;
      *.zip)       unzip $1     ;;
      *.Z)         uncompress $1;;
      *.7z)        7z x $1      ;;
      *)           echo "'$1' cannot be extracted via ex()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

PATH_preappend ~/.local/bin/

# https://wiki.archlinux.org/title/SSH_keys#SSH_agents
# make sure ssh-agent process runs at a time
if ! pgrep -u "$USER" ssh-agent > /dev/null; then
    ssh-agent -t 1h > "$XDG_RUNTIME_DIR/ssh-agent.env"
fi
if [[ ! "$SSH_AUTH_SOCK" ]]; then
    source "$XDG_RUNTIME_DIR/ssh-agent.env" >/dev/null
fi

# do not blink in red background when missing something
# https://stackoverflow.com/a/65839614
# LS_COLORS=$(echo $LS_COLORS | sed -E 's/:(or|mi)=[^:]+/:\1=03/g')
LS_COLORS=$(echo $LS_COLORS | sed -E 's/:(or|mi)=[^:]+/:\1=02/g')
# below should be ignored by git by filter
